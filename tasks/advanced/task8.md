# Задание 8 (4 балла)

В объектной системе Python отсутствует понятие интерфейса, то есть нельзя
гарантировать, что класс определяет некоторое фиксированное множество атрибутов
и методов. Этот "пробел" можно восполнить с помощью декоратора класса.

**a)** Напишите функцию `peel`, которая принимает класс и возвращает множество
всех публичных атрибутов и методов класса. Если у класса есть родитель, то
результат функции `peel` должен включать также публичные методы родителя.
Публичными считаются атрибуты и методы, имя которых не начинается с символа
подчёркивания.

```
>>> class AbstractBase:
... def some_method(self):
... pass
...
>>> class Base(AbstractBase):
... def some_other_method(self):
... pass
...
>>> class Closeable(Base):
... def close(self):
... pass
...
>>> peel(Closeable)
{"some_method", "some_other_method", "close"}
```

Вам может быть полезна функция `dir`, которая принимает класс или экземпляр
класса и возвращает список его атрибутов и методов с учётом наследования.

```
>>> class A:
... some_list = []
...
>>> class B(A):
... some_other_attribute = 42
...
>>> dir(A)
[..., 'some_list']
>>> dir(B())
[..., 'some_list', 'some_other_attribute']
```

**b)** Реализуйте декоратор класса `implements`, который проверяет, что класс
реализует "интерфейс", переданный декоратору в качестве аргумента. Для простоты
можно считать, что класс реализует "интерфейс", если все публичные атрибуты и
методы "интерфейса" являются публичными методами и атрибутами проверяемого
класса.

```
>>> class Closeable:
... def close(self):
... pass
...
>>> @implements(Closeable)
... class FileReader:
... # ...
... def close(self):
... self.file.close()
```

В случае неуспешной проверки должен сработать оператор `assert`:

```
>>> @implements(Closeable)
... class Noop:
... pass
...
Traceback (most recent call last):
File "", line 1, in
File "", line 6, in wrapper
AssertionError: method 'close' not implemented
```
