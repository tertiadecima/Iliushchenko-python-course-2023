# Задание 7 (6 баллов)

Опечатки - ежедневная проблема всех пользователей компьютера. Борьбе с
опечатками посвящено большое количество
[публикаций](http://scholar.google.com/scholar?q=spelling+correction).
Мы попробуем решить задачу исправления опечаток для списка слов.

**a)** Напишите функцию `build_graph`, которая по заданному списку слов `words` и
значению `mismatch_percent` строит неориентированный граф, называемый графом
Хемминга. Каждое слово из списка `words` это метка, соответствующей ему вершины
в графе. Ребро между двумя вершинами проводится, если:
- длины строк, соответствующих вершинам, равны,
- `d <= mismatch_percent * n / 100`, где `d` -- расстояние Хемминга между
двумя строками, а `n` -- их длина.

```
>>> words = ["hello", "helol", "ehllo", "tiger", "field"]
>>> g = build_graph(words, mismatch_percent=50.)
>>> g
{0: [1, 2], 1: [0], 2: [0], 3: [], 4: []}
```

Обратите внимание, что одинаковым словам в списке `words` соответствуют разные
вершины в итоговом графе.

**b)** Неориентированный граф в Python удобно представлять в виде словаря, ключи
которого -- вершины графа, а значения -- соответствующие списки смежности. Часто
вершины графа как-то занумерованы и представляются в виде чисел. Также у вершин
есть текстовые метки, которые хранятся в отдельном списке.

Напишите функцию `export_graph`, которая принимает граф и список меток для
каждой вершины графа и возвращает граф в формате
[DOT](https://en.wikipedia.org/wiki/DOT_(graph_description_language)). Формат
DOT по сути представляет собой список ребер с метаданными.

Порядок следования строчек внутри оператора `graph` не важен.

Обратите внимание, что для каждой пары вершин из графа в DOT файле должно
остаться не более одного ребра. Направление ребра в файле значения не имеет, то
есть ребро `(0, 1)` можно записать либо как `0 -- 1`, либо как `1 -- 0`.

```
>>> g = {0: [1, 2], 1: [0], 2: [0]}
>>> labels = ["a", "b", "c"]
>>> print(export_graph(g, labels))
graph {
0 [label="a"]
0 -- 1
0 -- 2
1 [label="b"]
2 [label="c"]
}
```

Для визулизации DOT файлов можно воспользоваться сервисом
[WebGraphviz](http://www.webgraphviz.com/).

**c)** Напишите функцию `find_connected_components`, которая по заданному
неориентированному графу строит список его компонент связности:

```
>>> g = {0: [1, 2], 1: [0], 2: [0], 3: [], 4: []}
>>> find_connected_components(g)
[{0, 1, 2}, {3}, {4}]
```

**d)** Напишите функцию `find_consensus`, которая принимает на вход список слов
одинаковой длины. Она возвращает строку, в которой i-й символ -- наиболее
часто встречающаяся буква, стоящая в i-й позиции, во всех словах из списка.
Найденная строка называется консенсусной. Если консенсусных строк несколько,
можно вернуть любую.

```
>>> find_consensus(["hello", "helol", "ehllo"])
'hello'
>>> find_consensus(["bug", "bow", "bag", "bar"])
'bag'
```

**e)** Напишите функцию `correct_typos`, которая
принимает на вход список слов и значение `mismatch_percent`
и возвращает новый список, где слова с опечатками исправлены.

Исправление слов происходит по следующему алгоритму.

- Строим по списку слов граф Хемминга, используя переданное значение
`mismatch_percent`.
- Ищем в полученном графе компоненты связности.
- Для каждой найденной компоненты связности строим консенсусную строку и
исправляем с помощью неё все слова из этой компоненты. Исправить в данном
случае означает заменить слово с опечаткой на соответствующую консенсусную
строку.

```
>>> words = ["hello", "helol", "ehllo", "tiger", "field", "abracadabra"]
>>> correct_typos(words, mismatch_percent=50.)
['hello', 'hello', 'hello', 'tiger', 'field', 'abracadabra']
```
